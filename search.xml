<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试（java方向）]]></title>
    <url>%2F2018%2F11%2F21%2F%E9%9D%A2%E8%AF%95(java%E6%96%B9%E5%90%91)%2F</url>
    <content type="text"><![CDATA[原文地址：github.com/kdn251/interviews 译文出自：掘金翻译计划 译者：王下邀月熊 校对者：PhxNirvana、根号三 这个 链接 用来查看本翻译与英文版是否有差别（如果你没有看到 README.md 发生变化，那就意味着这份翻译文档是最新的）。 Interviews 软件工程技术面试个人指南。 Maintainer - Kevin Naughton Jr. 其他语言版本 English 目录 在线练习 在线面试编程 数据结构 算法 位运算 算法复杂度分析 视频教程 面试书籍 计算机科学与技术资讯 文件结构 在线练习 LeetCode Virtual Judge CareerCup HackerRank CodeFights Kattis HackerEarth Codility Code Forces Code Chef Sphere Online Judge - SPOJ InterviewBit 在线面试编程 Pramp Gainlo Refdash Interviewing.io 数据结构Linked List 链表即是由节点（Node）组成的线性集合，每个节点可以利用指针指向其他节点。它是一种包含了多个节点的、能够用于表示序列的数据结构。 单向链表: 链表中的节点仅指向下一个节点，并且最后一个节点指向空。 双向链表: 其中每个节点具有两个指针 p、n，使得 p 指向先前节点并且 n 指向下一个节点；最后一个节点的 n 指针指向 null。 循环链表：每个节点指向下一个节点并且最后一个节点指向第一个节点的链表。 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) Stack 栈是元素的集合，其包含了两个基本操作：push 操作可以用于将元素压入栈，pop 操作可以将栈顶元素移除。 遵循后入先出（LIFO）原则。 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) Queue 队列是元素的集合，其包含了两个基本操作：enqueue 操作可以用于将元素插入到队列中，而 dequeue 操作则是将元素从队列中移除。 遵循先入先出原则 (FIFO)。 时间复杂度: 索引: O(n) 搜索: O(n) 插入: O(1) 移除: O(1) Tree 树是无向、连通的无环图。 Binary Tree 二叉树即是每个节点最多包含左子节点与右子节点这两个节点的树形数据结构。 满二叉树: 树中的每个节点仅包含 0 或 2 个节点。 完美二叉树（Perfect Binary Tree）: 二叉树中的每个叶节点都拥有两个子节点，并且具有相同的高度。 完全二叉树: 除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。 Binary Search Tree 二叉搜索树（BST）是一种特殊的二叉树，其任何节点中的值都会大于或者等于其左子树中存储的值并且小于或者等于其右子树中存储的值。 时间复杂度: 索引: O(log(n)) 搜索: O(log(n)) 插入: O(log(n)) 删除: O(log(n)) Trie 字典树，又称基数树或者前缀树，能够用于存储键为字符串的动态集合或者关联数组的搜索树。树中的节点并没有直接存储关联键值，而是该节点在树中的挂载位置决定了其关联键值。某个节点的所有子节点都拥有相同的前缀，整棵树的根节点则是空字符串。 Fenwick Tree 树状数组又称 Binary Indexed Tree，其表现形式为树，不过本质上是以数组实现。数组中的下标代表着树中的顶点，每个顶点的父节点或者子节点的下标能够通过位运算获得。数组中的每个元素包含了预计算的区间值之和，在整棵树更新的过程中同样会更新这些预计算的值。 时间复杂度: 区间求值: O(log(n)) 更新: O(log(n)) Segment Tree 线段树是用于存放间隔或者线段的树形数据结构，它允许快速的查找某一个节点在若干条线段中出现的次数. 时间复杂度: 区间查询: O(log(n)) 更新: O(log(n)) Heap 堆是一种特殊的基于树的满足某些特性的数据结构，整个堆中的所有父子节点的键值都会满足相同的排序条件。堆更准确地可以分为最大堆与最小堆，在最大堆中，父节点的键值永远大于或者等于子节点的值，并且整个堆中的最大值存储于根节点；而最小堆中，父节点的键值永远小于或者等于其子节点的键值，并且整个堆中的最小值存储于根节点。 时间复杂度: 访问最大值 / 最小值: O(1) 插入: O(log(n)) 移除最大值 / 最小值: O(log(n)) Hashing 哈希能够将任意长度的数据映射到固定长度的数据。哈希函数返回的即是哈希值，如果两个不同的键得到相同的哈希值，即将这种现象称为碰撞。 Hash Map: Hash Map 是一种能够建立起键与值之间关系的数据结构，Hash Map 能够使用哈希函数将键转化为桶或者槽中的下标，从而优化对于目标值的搜索速度。 碰撞解决 链地址法（Separate Chaining）: 链地址法中，每个桶是相互独立的，包含了一系列索引的列表。搜索操作的时间复杂度即是搜索桶的时间（固定时间）与遍历列表的时间之和。 开地址法（Open Addressing）: 在开地址法中，当插入新值时，会判断该值对应的哈希桶是否存在，如果存在则根据某种算法依次选择下一个可能的位置，直到找到一个尚未被占用的地址。所谓开地址法也是指某个元素的位置并不永远由其哈希值决定。 Graph 图是一种数据元素间为多对多关系的数据结构，加上一组基本操作构成的抽象数据类型。 无向图（Undirected Graph）: 无向图具有对称的邻接矩阵，因此如果存在某条从节点 u 到节点 v 的边，反之从 v 到 u 的边也存在。 有向图（Directed Graph）: 有向图的邻接矩阵是非对称的，即如果存在从 u 到 v 的边并不意味着一定存在从 v 到 u 的边。 算法排序快速排序 稳定: 否 时间复杂度: 最优时间: O(nlog(n)) 最坏时间: O(n^2) 平均时间: O(nlog(n)) 归并排序 归并排序是典型的分治算法，它不断地将某个数组分为两个部分，分别对左子数组与右子数组进行排序，然后将两个数组合并为新的有序数组。 稳定: 是 时间复杂度: 最优时间: O(nlog(n)) 最坏时间: O(nlog(n)) 平均时间: O(nlog(n)) 桶排序 桶排序将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 时间复杂度: 最优时间: Ω(n + k) 最坏时间: O(n^2) 平均时间:Θ(n + k) 基数排序 基数排序类似于桶排序，将数组分割到有限数目的桶中；不过其在分割之后并没有让每个桶单独地进行排序，而是直接进行了合并操作。 时间复杂度: 最优时间: Ω(nk) 最坏时间: O(nk) 平均时间: Θ(nk) 图算法深度优先搜索 深度优先算法是一种优先遍历子节点而不是回溯的算法。 时间复杂度: O(|V| + |E|) 广度优先搜索 广度优先搜索是优先遍历邻居节点而不是子节点的图遍历算法。 时间复杂度: O(|V| + |E|) 拓扑排序 拓扑排序是对于有向图节点的线性排序，如果存在某条从 u 到 v 的边，则认为 u 的下标先于 v。 时间复杂度: O(|V| + |E|) Dijkstra 算法 Dijkstra 算法 用于计算有向图中单源最短路径问题。 时间复杂度: O(|V|^2) Bellman-Ford 算法 Bellman-Ford 算法是在带权图中计算从单一源点出发到其他节点的最短路径的算法。 尽管算法复杂度大于 Dijkstra 算法，但是它适用于包含了负值边的图。 时间复杂度: 最优时间: O(|E|) 最坏时间: O(|V||E|) Floyd-Warshall 算法 Floyd-Warshall 算法 能够用于在无环带权图中寻找任意节点的最短路径。 时间复杂度: 最优时间: O(|V|^3) 最坏时间: O(|V|^3) 平均时间: O(|V|^3) Prim 算法 Prim 算法是用于在带权无向图中计算最小生成树的贪婪算法。换言之，Prim 算法能够在图中抽取出连接所有节点的边的最小代价子集。 时间复杂度: O(|V|^2) Kruskal 算法 Kruskal 算法同样是计算图的最小生成树的算法，与 Prim 的区别在于并不需要图是连通的。 时间复杂度: O(|E|log|V|) 位运算 位运算即是在位级别进行操作的技术，合适的位运算能够帮助我们得到更快地运算速度与更小的内存使用。 测试第 k 位: s &amp; (1 &lt;&lt; k) 设置第 k 位: s |= (1 &lt;&lt; k) 第 k 位置零: s &amp;= ~(1 &lt;&lt; k) 切换第 k 位值: s ^= ~(1 &lt;&lt; k) 乘以 2n: s &lt;&lt; n 除以 2n: s &gt;&gt; n 交集: s &amp; t 并集: s | t 减法: s &amp; ~t 交换 x = x ^ y ^ (y = x) 取出最小非 0 位（Extract lowest set bit）: s &amp; (-s) 取出最小 0 位（Extract lowest unset bit）: ~s &amp; (s + 1) 交换值:123x ^= y;y ^= x;x ^= y; 算法复杂度分析大 O 表示 大 O 表示 用于表示某个算法的上限，往往用于描述最坏的情况。 小 O 表示 小 O 表示用于描述某个算法的渐进上界，不过二者要更为紧密。 大 Ω 表示 大 Ω 表示用于描述某个算法的渐进下界。 小 ω 表示 Little Omega Notation用于描述某个特定算法的下界，不过不一定很靠近。 Theta Θ 表示 Theta Notation用于描述某个确定算法的确界。 视频教程 Data Structures UC Berkeley Data Structures MIT Advanced Data Structures Algorithms MIT Introduction to Algorithms MIT Advanced Algorithms 面试书籍 Competitive Programming 3 - Steven Halim &amp; Felix Halim Cracking The Coding Interview - Gayle Laakmann McDowell Cracking The PM Interview - Gayle Laakmann McDowell &amp; Jackie Bavaro 计算机科学与技术资讯 Hacker News Lobsters 文件结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145.├── Array│ ├── bestTimeToBuyAndSellStock.java│ ├── findTheCelebrity.java│ ├── gameOfLife.java│ ├── increasingTripletSubsequence.java│ ├── insertInterval.java│ ├── longestConsecutiveSequence.java│ ├── maximumProductSubarray.java│ ├── maximumSubarray.java│ ├── mergeIntervals.java│ ├── missingRanges.java│ ├── productOfArrayExceptSelf.java│ ├── rotateImage.java│ ├── searchInRotatedSortedArray.java│ ├── spiralMatrixII.java│ ├── subsetsII.java│ ├── subsets.java│ ├── summaryRanges.java│ ├── wiggleSort.java│ └── wordSearch.java├── Backtracking│ ├── androidUnlockPatterns.java│ ├── generalizedAbbreviation.java│ └── letterCombinationsOfAPhoneNumber.java├── BinarySearch│ ├── closestBinarySearchTreeValue.java│ ├── firstBadVersion.java│ ├── guessNumberHigherOrLower.java│ ├── pow(x,n).java│ └── sqrt(x).java├── BitManipulation│ ├── binaryWatch.java│ ├── countingBits.java│ ├── hammingDistance.java│ ├── maximumProductOfWordLengths.java│ ├── numberOf1Bits.java│ ├── sumOfTwoIntegers.java│ └── utf-8Validation.java├── BreadthFirstSearch│ ├── binaryTreeLevelOrderTraversal.java│ ├── cloneGraph.java│ ├── pacificAtlanticWaterFlow.java│ ├── removeInvalidParentheses.java│ ├── shortestDistanceFromAllBuildings.java│ ├── symmetricTree.java│ └── wallsAndGates.java├── DepthFirstSearch│ ├── balancedBinaryTree.java│ ├── battleshipsInABoard.java│ ├── convertSortedArrayToBinarySearchTree.java│ ├── maximumDepthOfABinaryTree.java│ ├── numberOfIslands.java│ ├── populatingNextRightPointersInEachNode.java│ └── sameTree.java├── Design│ └── zigzagIterator.java├── DivideAndConquer│ ├── expressionAddOperators.java│ └── kthLargestElementInAnArray.java├── DynamicProgramming│ ├── bombEnemy.java│ ├── climbingStairs.java│ ├── combinationSumIV.java│ ├── countingBits.java│ ├── editDistance.java│ ├── houseRobber.java│ ├── paintFence.java│ ├── paintHouseII.java│ ├── regularExpressionMatching.java│ ├── sentenceScreenFitting.java│ ├── uniqueBinarySearchTrees.java│ └── wordBreak.java├── HashTable│ ├── binaryTreeVerticalOrderTraversal.java│ ├── findTheDifference.java│ ├── groupAnagrams.java│ ├── groupShiftedStrings.java│ ├── islandPerimeter.java│ ├── loggerRateLimiter.java│ ├── maximumSizeSubarraySumEqualsK.java│ ├── minimumWindowSubstring.java│ ├── sparseMatrixMultiplication.java│ ├── strobogrammaticNumber.java│ ├── twoSum.java│ └── uniqueWordAbbreviation.java├── LinkedList│ ├── addTwoNumbers.java│ ├── deleteNodeInALinkedList.java│ ├── mergeKSortedLists.java│ ├── palindromeLinkedList.java│ ├── plusOneLinkedList.java│ ├── README.md│ └── reverseLinkedList.java├── Queue│ └── movingAverageFromDataStream.java├── README.md├── Sort│ ├── meetingRoomsII.java│ └── meetingRooms.java├── Stack│ ├── binarySearchTreeIterator.java│ ├── decodeString.java│ ├── flattenNestedListIterator.java│ └── trappingRainWater.java├── String│ ├── addBinary.java│ ├── countAndSay.java│ ├── decodeWays.java│ ├── editDistance.java│ ├── integerToEnglishWords.java│ ├── longestPalindrome.java│ ├── longestSubstringWithAtMostKDistinctCharacters.java│ ├── minimumWindowSubstring.java│ ├── multiplyString.java│ ├── oneEditDistance.java│ ├── palindromePermutation.java│ ├── README.md│ ├── reverseVowelsOfAString.java│ ├── romanToInteger.java│ ├── validPalindrome.java│ └── validParentheses.java├── Tree│ ├── binaryTreeMaximumPathSum.java│ ├── binaryTreePaths.java│ ├── inorderSuccessorInBST.java│ ├── invertBinaryTree.java│ ├── lowestCommonAncestorOfABinaryTree.java│ ├── sumOfLeftLeaves.java│ └── validateBinarySearchTree.java├── Trie│ ├── addAndSearchWordDataStructureDesign.java│ ├── implementTrie.java│ └── wordSquares.java└── TwoPointers ├── 3Sum.java ├── 3SumSmaller.java ├── mergeSortedArray.java ├── minimumSizeSubarraySum.java ├── moveZeros.java ├── removeDuplicatesFromSortedArray.java ├── reverseString.java └── sortColors.java18 directories, 124 files]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇趣阁]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%A5%87%E8%B6%A3%E9%98%81%2F</url>
    <content type="text"><![CDATA[一. 主营内容二. 过去和现状2-1 低端路线过去：电商价格低，商家间常打价格战，导致假货泛滥，商品质量很低现在： 2-2 高端路线三. 思索正在考虑是否走高端路线]]></content>
      <categories>
        <category>电商</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[淘宝规则]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%B7%98%E5%AE%9D%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[淘宝规则链接]]></content>
      <categories>
        <category>电商</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[电商注意点]]></title>
    <url>%2F2018%2F10%2F27%2F%E7%94%B5%E5%95%86%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[当一个公司在某个领域专注几年后，会越来越专业，无论是在产品、供应链上还在在应用场景上，这些就形成了核心竞争力。 现在市场上有多个平台，如淘宝网、天猫、京东、苏宁、当当网等，有的企业一开始就全渠道开展，其实这不是一个好的选择。最好的方式是先专注于某个渠道，做顺了，业务发展到一定程度，再考虑扩充其他渠道。 中国提倡中庸文化，不能太左，也不能太右。做电商也是如此，不能太死板，也不能太投机。太死板，公司很难发展；太投机，公司风险很大。 产品创新能带来直接的利润。在互联网行业，创新的成本都不高，然而一旦成功，收益很大！如何才能进行产品创新？这里有几点建议: 跨类目组合。之前讲的几个例子都是如此。 解决生活痛点。 多找外行交流。问问用户有什么异想天开的想法，外行不懂，所以敢想。 热爱你自己的产品。深度热爱自己的产品，你会有把它们用到生活中的欲望，然后会有很多创意出来。 创新是可遇不可求的事，需要每天都琢磨，一旦有想法，就赶紧去找产品人员讨论。]]></content>
      <categories>
        <category>电商</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[maven国内阿里云镜像]]></title>
    <url>%2F2018%2F10%2F25%2Fmaven%E5%9B%BD%E5%86%85%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[maven确实是一个好东西，但是在国内下载官方仓库的jar却是个大问题，速度不敢恭维，现在oschina的国内maven镜像服务已关闭，无奈之下只能另寻门路。今天突然发现了阿里云maven国内镜像，修改完以后速度飞一般的感觉，超赞，这个激动啊。。。修改方法：在~/.m2目录下的settings.xml文件中，（如果该文件不存在，则需要从maven/conf目录下拷贝一份），找到标签，添加如下子标签：123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;]]></content>
      <categories>
        <category>构建工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Springboot使用jsp作为view视图]]></title>
    <url>%2F2018%2F10%2F25%2FSpringboot%E4%BD%BF%E7%94%A8jsp%E4%BD%9C%E4%B8%BAview%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[配置springboot支持jsp添加关于jsp相关的maven支持123456789101112131415&lt;!--springboot tomcat jsp支持开启--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--servlet支持开启--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--jstl支持开启--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 配置视图 要想让spring-boot支持JSP，需要将项目打成war包，所以需要在pom.xml中将jar改成war 在main目录下面依次建立文件夹，webapp/WEB-INF，就这样写死 打开springboot配置文件application.yml，添加下面的视图配置12345spring: mvc: view: prefix: /WEB-INF/ suffix: .jsp 然后将jsp文件放在WEB-INF这个目录下面就可以了 好了，下面我们建立相应的IndexController和index.jsp测试一下了~]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Springboot使用freemarker作为view视图]]></title>
    <url>%2F2018%2F10%2F25%2FSpringboot%E4%BD%BF%E7%94%A8freemarker%E4%BD%9C%E4%B8%BAview%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[添加FreeMaker依赖首先在pom.xml中添加FreeMaker的依赖1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中增加FreeMarker的配置12345678910spring: freemarker: allow-request-override: false cache: false check-template-location: true charset: UTF-8 content-type: text/html expose-request-attributes: false expose-session-attributes: false expose-spring-macro-helpers: false]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Springboot使用html作为view视图]]></title>
    <url>%2F2018%2F10%2F25%2FSpringboot%E4%BD%BF%E7%94%A8html%E4%BD%9C%E4%B8%BAview%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在pom.xml中增加thymeleaf依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 如果你的视图不是放在/templates/下面，需要在springboot文件中更改view的视图路径 1234spring: thymeleaf: prefix: classpath:/templates suffix: .html]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA 使用Spring-boot-devTools无效解决办法]]></title>
    <url>%2F2018%2F10%2F25%2FIntellij-IDEA-%E4%BD%BF%E7%94%A8Spring-boot-devTools%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[相信大部分使用Intellij的同学都会遇到这个问题，即使项目使用了spring-boot-devtools，修改了类或者html、js等，idea还是不会自动重启，非要手动去make一下或者重启，就更没有使用热部署一样。出现这种情况，并不是你的配置问题，相信自己，热部署那几个设置很简单，其根本原因是因为Intellij IEDA和Eclipse不同，Eclipse设置了自动编译之后，修改类它会自动编译，而IDEA在非RUN或DEBUG情况下才会自动编译（前提是你已经设置了Auto-Compile）。废话这么多，怎么解决呢？请耐心往下看。首先，IDEA设置里面这里必须打勾 然后 Shift+Ctrl+Alt+/，选择Registry 进去之后，找到如下图所示的选项，打勾 ok了，重启一下项目，然后改一下类里面的内容，IDEA就会自动去make了。 转自：http://blog.csdn.net/wjc475869/article/details/52442484]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解析Unicode字符串]]></title>
    <url>%2F2018%2F10%2F25%2F%E8%A7%A3%E6%9E%90Unicode%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 解析unicode字符串 * @param unicodeStr * @return */ public static String readUnicodeStr(String unicodeStr) &#123; StringBuilder buf = new StringBuilder(); for (int i = 0; i &lt; unicodeStr.length(); i++) &#123; char char1 = unicodeStr.charAt(i); if (char1 == '\\' &amp;&amp; isUnicode(unicodeStr, i)) &#123; String cStr = unicodeStr.substring(i + 2, i + 6); int cInt = Integer.parseInt(cStr,16); buf.append((char) cInt); // 跨过当前unicode码，因为还有i++，所以这里i加5，而不是6 i = i + 5; &#125; else &#123; buf.append(char1); &#125; &#125; return buf.toString(); &#125; // 判断以index从i开始的串，是不是unicode码 private static boolean isUnicode(String unicodeStr, int i) &#123; int len = unicodeStr.length(); int remain = len - i; // unicode码，反斜杠后还有5个字符 uxxxx if (remain &lt; 5) return false; char flag2 = unicodeStr.charAt(i + 1); if (flag2 != 'u') return false; String nextFour = unicodeStr.substring(i + 2, i + 6); return isHexStr(nextFour); &#125; /** hex str 0-9 a-f A-F */ private static boolean isHexStr(String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; char ch = str.charAt(i); boolean isHex = ch &gt;= '0' &amp;&amp; ch &lt;= '9' || ch &gt;= 'a' &amp;&amp; ch &lt;= 'f' || ch &gt;= 'A' &amp;&amp; ch &lt;= 'F'; if (!isHex) return false; &#125; return true; &#125; 来自：http://blog.csdn.net/shigang_xing/article/details/8263728]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[View到达顶部及底部边界判断]]></title>
    <url>%2F2018%2F10%2F25%2FView%E5%88%B0%E8%BE%BE%E9%A1%B6%E9%83%A8%E5%8F%8A%E5%BA%95%E9%83%A8%E8%BE%B9%E7%95%8C%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[判断View是否滑动到顶部1234567891011121314151617181920 /** * 判断View是否滑动到顶部 * @param view * @return */public static &lt;V extends View&gt; boolean isViewReachTopEdge(V view) &#123; if (view instanceof ViewGroup) &#123; if (view.canScrollVertically(-1)) return false; int count = ((ViewGroup)view).getChildCount(); for (int i = 0; i &lt; count; i++) &#123; if (!isViewReachTopEdge(((ViewGroup)view).getChildAt(i))) //递归子View return false; &#125; &#125; if (view.canScrollVertically(-1)) &#123; return false; &#125; return true; &#125; 判断View是否滑动到底部1234567891011121314151617181920/** * 判断View是否滑动到底部 * @param view * @return */public static &lt;V extends View&gt; boolean isViewReachBottomEdge(V view) &#123; if (view instanceof ViewGroup) &#123; if (view.canScrollVertically(1)) return false; int count = ((ViewGroup)view).getChildCount(); for (int i = 0; i &lt; count; i++) &#123; if (!isViewReachBottomEdge(((ViewGroup)view).getChildAt(i))) //递归子View return false; &#125; &#125; if (view.canScrollVertically(1)) &#123; return false; &#125; return true;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Text文本的绘制]]></title>
    <url>%2F2018%2F10%2F25%2FAndroid-Text%E6%96%87%E6%9C%AC%E7%9A%84%E7%BB%98%E5%88%B6%2F</url>
    <content type="text"><![CDATA[文字的范围是asent的高度加上desent的高度，所以我们只要让文字上边界与top线的距离跟下边界与bottom线的距离相等即可，然后baseline的Y坐标就是文字上边界与top线的高度加上ascent的高度即可（注：baseLine以上为负，以下为正） 12345// 计算文字BaseLinePaint.FontMetricsInt fontMetrics = mPaint.getFontMetricsInt();int baseLineY = getMeasuredHeight()/2 + (fontMetrics.descent- fontMetrics.ascent)/2 -fontMetrics.descent;canvas.drawText(nameFirstChar, width / 2, textBaseY, paint);viewHolder.iv_avatar.setImageBitmap(CommonMethod.toRoundCorner(bitmap, width));]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android常用开源库]]></title>
    <url>%2F2018%2F10%2F25%2FAndroid%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%BA%93%2F</url>
    <content type="text"><![CDATA[一款用于在滚动视图中观测滚动事件的Android库（与Material Design实现交互）：Android-ObservableScrollViewMaterial Design Music Player：TimberMaterial风格的EditText：MaterialEditTextAndroid 多主题框架：MagicaSakuraMaterialDesign图标库：material-design-iconsAndroid动画开源库：AndroidViewAnimationsDagger2：dagger2图片裁剪库：uCrop强大、可定制、易扩展的 ViewPager 指示器框架：MagicIndicator是一个方便简约的 Android 图片压缩工具库：AdvancedLubanRxJava：RxJava一套简单的api去申明android6.0以上的运行时权限：PermissionsDispatcherretrofit：retrofit仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果：Android-PickerViewAndroid Material风格评分：android-material-app-rating拖拽消失气泡（类QQ消息数目拖拽消失效果）：BGABadgeView-Android爆炸效果：ExplosionField打造炫酷列表之 StickyHeaderListView：标题渐变、吸附悬浮、筛选分类、动态头部等：StickyHeaderListView实现随手势放大缩小的图片：PhotoView垂直翻页公告：MarqueeViewViewPager自动轮播器：RollViewPager开源表情键盘：XhsEmoticonsKeyboard动画库：lottie-android支持多/单图片选择和预览，单图裁剪功能（B站出品）：boxingTextView部分文字实现变颜色及可点击：Android-TextView-LinkBuilder安卓表格：smartTable安卓开源视频播放器： JiaoZiVideoPlayer安卓字体图标库：Android-Iconics验证码输入框：VerificationCodeView评分控件：MaterialRatingBar透明状态栏：ImmersionBarAndroid路由跳转：ARouter手势图形解锁：PatternLockView图像压缩：Tiny图片或视频选择：Matisse 安卓架构文章合集：AndroidArchitectureCollection]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo建站教程]]></title>
    <url>%2F2018%2F10%2F23%2Fhexo%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[hexo建站教程]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux服务器设置静态IP]]></title>
    <url>%2F2018%2F10%2F23%2Flinux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip%2F</url>
    <content type="text"><![CDATA[centos 修改 /etc/sysconfig/network-scripts/ifcfg-eth0 123456DEVICE=eth0 #网卡对应的设备别名BOOTPROTO=static #网卡获得ip地址的方式（默认为dhcp，表示自动获取）HWADDR=00:07:E9:05:E8:B4 #网卡MAC地址（物理地址）IPADDR=192.168.100.100 #IP地址NETMASK=255.255.255.0 #子网掩码 ONBOOT=yes 重启网络配置 1service network restart ubuntu 修改 /etc/sysconfig/network-scripts/ifcfg-eth0 12345auto eth0iface eth0 inet staticaddress 192.168.3.90gateway 192.168.3.1netmask 255.255.255.0 重启网络配置 1sudo /etc/init.d/networking restart]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
</search>
